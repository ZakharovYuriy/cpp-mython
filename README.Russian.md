# cpp-mython
Интерпретатор языка Mython. Создание собственного DSL.

Читать на других языках: [English](README.md), [Русский](README.Russian.md)

# Описание программы
Mython(Mini-python. Встречается расшифровка My Python, но в ней речь о другом Mython) — упрощённое подмножество Python.<br>
В Mython есть **классы** и **наследование**, а все **методы** — **виртуальные**.<br>

# Сборка при помощи Cmake
To build this project on linux you need:<br>
1)If you don't have Cmake installed, install Cmake<br>
2)If the "Debug" or "Release" folders are not created:<br>

```
mkdir Debug
mkdir Release
```
3)Run the command for Debug and Release conf:<br>

```
cmake -E chdir Debug/ cmake -G "Unix Makefiles" ../ -DCMAKE_BUILD_TYPE:STRING=Debug
cmake -E chdir Release/ cmake -G "Unix Makefiles" ../ -DCMAKE_BUILD_TYPE:STRING=Release
```
4)Build command:<br>

```
cmake --build Debug/.
cmake --build Release/.
```

5)To **Run** program- go to the debug (cd Debug/) or release (cd Release/) folder and run:<br>

```
./mython
```
6)После сообщений об успешном прохождении тестов, вы можете ввести свою программу на Mython, а затем, вконце программы для полученния ответа введите в кконнсоль команнду **ctrl+D**<br>

**ALL in one command(Release)**:<br>

```
mkdir Release; cmake -E chdir Release/ cmake -G "Unix Makefiles" ../ -DCMAKE_BUILD_TYPE:STRING=Release && cmake --build Release/.
```

# Системые требования:
  1. C++17(STL)<br>
  2. GCC (MinG w64) 11.2.0  <br>
  
# Планы по доработке:
0. Добавить UI<br>
1. Добавить возможность чтения документов из файлов<br>
2. Добавить поддержку дробных чисел<br>
3. Добавить больше арифметическмх действий<br>

# Стек технологий:
0. ООП<br>
1. Abstract Syntax Tree (AST).<br>
2. Наследование<br>
3. Таблица виртуальных методов<br>
4. Лексический анализатор, или лексер.<br>
5. Синтаксический анализатор, или парсер.<br>
6. Семантический анализатор.<br>

# Использование
## Перед тем как начать:
  0. Установка и настройкка всех требуемых компонентов в среде разработки длля запуска приложения
  1. Вариант использования показан в tests.h, lexer_test_open.cpp, parse_test.cpp
  2. При запуске программы можно просмотреть краткую справку, с помошью параметра -help или -h
  3. Программу можно запустить в режиме тестирования, с помошью параметра -test или -t
  
# Описание возможностей:
## Числа
В языке Mython используются только целые числа. С ними можно выполнять обычные арифметические операции: сложение, вычитание, умножение, целочисленное деление.<br>
## Строки в Mython — неизменяемые.
Строковая константа в Mython — это последовательность произвольных символов, размещающаяся на одной строке и ограниченная двойными кавычками " или одинарными '. Поддерживается экранирование спецсимволов '\n', '\t', '\'' и '\"'. [пример 1](#1-примеры-строк-в-mython) <br>
## Логические константы и None
Кроме строковых и целочисленных значений язык Mython поддерживает логические значения **True** и **False**. Есть также специальное значение **None**, аналог nullptr в С++. В отличие от C++, логические константы пишутся с большой буквы.<br>
## Комментарии
Mython поддерживает однострочные комментарии, начинающиеся с символа #. Весь следующий текст до конца текущей строки игнорируется. # внутри строк считается обычным символом. [пример 2](#2-примеры-коментариев-в-mython)<br>
## Идентификаторы
Идентификаторы в Mython используются для обозначения имён переменных, классов и методов. Идентификаторы формируются так же, как в большинстве других языков программирования: начинаются со строчной или заглавной латинской буквы либо с символа подчёркивания. Потом следует произвольная последовательность, состоящая из цифр, букв и символа подчёркивания. [пример 3](#3-примеры-идентификаторов-в-mython)<br>
## Классы
В Mython можно определить свой тип, создав класс. Как и в С++, класс имеет поля и методы, но, в отличие от С++, поля не надо объявлять заранее.<br>
Объявление класса начинается с ключевого слова class, за которым следует идентификатор имени и объявление методов класса.<br>
<br>
Важные отличия классов в Mython от классов в C++:
 - Специальный метод **__init__** играет роль конструктора — он автоматически вызывается при создании нового объекта класса. Метод **__init__** может отсутствовать.
 - Неявный параметр всех методов — специальный параметр **self**, аналог указателя this в C++. Параметр **self** ссылается на текущий объект класса.<br>
 - Поля не объявляются заранее, а добавляются в объект класса при первом присваивании. Поэтому обращения к полям класса всегда надо начинать с **self**., чтобы отличать их от локальных переменных.<br>
 - Все поля объекта — публичные.<br>
Новый объект ранее объявленного класса создаётся так же, как в C++: указанием имени класса, за которым в скобках идут параметры, передаваемые методу **__init__**.<br>

```
r = Rect(10, 5) 
```
В этой программе создаётся новый объект класса Rect. При вызове метода **__init__** параметр w будет иметь значение 10, а параметр h — 5. Созданный прямоугольник будет доступен в переменной r. [пример 4](#4-пример-класса-прямоугольник)<br>

## Типизация
В отличие от C++, Mython — это язык с динамической типизацией. В нём тип каждой переменной определяется во время исполнения программы и может меняться в ходе её работы. Поэтому вместо «присваивания переменной значения» лучше говорить о «связывании значения с некоторым именем». Благодаря динамической типизации при первом использовании переменной не надо указывать её тип. [пример 5](#5-пример-динамической-типизации)<br>

## Операции
В Mython определены:<br>
 - Арифметические операции для целых чисел, деление выполняется нацело. Деление на ноль вызывает ошибку времени выполнения.<br>
 - Операция конкатенации строк, например: `s = 'hello, ' + 'world'.`<br>
 - Операции сравнения строк и целых чисел `==, !=, <=, >=, <, >`; сравнение строк выполняется - лексикографически.<br>
 - Логические операции `and, or, not`.<br>
 - Унарный минус.<br>
 
Приоритет операций (в порядке убывания приоритета):<br>
 - Унарный минус.<br>
 - Умножение и деление.<br>
 - Сложение и вычитание.<br>
 - Операции сравнения.<br>
 - Логические операции.<br>
 
Порядок вычисления выражений может быть изменён скобками:<br>
`print 2 + 3 * 4   # выведет 14`<br>
`print (2 + 3) * 4 # выведет 20 `<br>

В Mython операция сложения кроме чисел и строк применима к объектам классов со специальным методом **__add__** [пример 6](#6-пример-операции-сложения-объектов-классов-со-специальным-методом-add)<br>

Операции сравнения применяются не только к числам и строкам, но и к объектам классов, имеющих методы **__eq__** (проверка «равно») и **__lt__** (проверка «меньше»). Используя эти методы, можно реализовать все операции сравнения. [пример 7](#7-пример-применения-операции-сравнения-к-объектам-классов) <br>

## Функция str
Функция **str** преобразует переданный ей аргумент в строку. Если аргумент — объект класса, она вызывает у него специальный метод **__str__** и возвращает результат. Если метода **__str__** в классе нет, функция возвращает строковое представление адреса объекта в памяти. Примеры:<br>
 - `str('Hello') вернёт строку Hello;`<br>
 - `str(100500) вернёт строку 100500;`<br>
 - `str(False) вернёт строку False;`<br>
 - `str(Rect(3, 4)) вернёт адрес объекта в памяти, например 0x2056fd0.`<br>
 [пример 8](#8-пример-класса-с-методом-str)<br>
 
## Команда print
Специальная команда **print** принимает набор аргументов, разделённых запятой, печатает их в стандартный вывод и дополнительно выводит перевод строки. Посмотрите на этот код:<br>

```
x = 4
w = 'world'
print x, x + 6, 'Hello, ' + w 
```
Он выведет:<br>
`4 10 Hello, world `<br>
Команда **print** вставляет пробел между выводимыми значениями. Если ей не передать аргументы, она просто выведет перевод строки.<br>
Чтобы преобразовать каждый свой аргумент в строку, команда **print** вызывает для него функцию **str**. Таким образом, команда `print Rect(20, 15)` выведет в stdout строку `Rect(20x15)`.<br>

## Условный оператор
В Mython есть условный оператор. [пример 9](#9-пример-использования-условного-оператора)<br>

## Наследование
В языке Mython у класса может быть один родительский класс. Если он есть, он указывается в скобках после имени класса и до символа двоеточия.<br>
Наследование в Mython работает так же, как в C++, — все методы родительского класса становятся доступны классу-потомку. При этом все методы публичные и виртуальные. [пример 10](#10-в-примере-ниже-класс-rect-наследуется-от-класса-shape)<br>

## Методы
Методы в Mython имеют синтаксис:

```
def <имя метода>(<список параметров>):
  <действие 1>
  <действие 2>
  ...
  <действие N> 
```
Ключевое слово def располагается с отступом в два пробела относительно класса. Инструкции, составляющие тело метода, имеют отступ в два пробела относительно ключевого слова def.<br>
Как и в случае полей класса, обращения к полям и методам текущего класса надо начинать с self.:<br>

```
class Factorial:
  def calc(n):
    if n == 0:
      return 1
    return n * self.calc(n - 1)

fact = Factorial()
print fact.calc(4) # Prints 24 
```
Этот пример также показывает поддержку рекурсии, которая компенсирует отсутствие циклов в языке.<br>
Команда return завершает выполнение метода и возвращает из него результат вычисления своего аргумента. Если исполнение метода не достигает команды return, метод возвращает None.<br>

## Семантика присваивания
Как сказано выше, Mython — это язык с динамической типизацией, поэтому операция присваивания имеет семантику не копирования значения в область памяти, а связывания имени переменной со значением. Как следствие, переменные только ссылаются на значения, а не содержат их копии. Говоря терминологией С++, переменные в Mython — указатели. Аналог nullptr — значение None. [пример 11](#11-пример-семантики-присваивания)<br>

## Прочие ограничения
Результат вызова метода или конструктора в Mython — терминальная операция. Её результат можно присвоить переменной или использовать в виде параметра функции или команды, но обратиться к полям и методам возвращённого объекта напрямую нельзя:<br>

```
# Так нельзя
print Rect(10, 5).w
# А вот так можно
r = Rect(10, 5)
print r.w 
```

# Структура
## Интерпретатор состоит из четырёх основных логических блоков:
 - Лексический анализатор, или лексер.<br>
 - Синтаксический анализатор, или парсер.<br>
 - Семантический анализатор.<br>
 - Таблица символов.<br>
 
### Лексический анализ
Первая фаза называется лексический анализ или сканирование. Лексический анализатор — считывает последовательность символов, которые составляют исходную программу, и формирует из них значащие последовательности символов — лексемы. Для каждой лексемы анализатор строит выходной токен вида:<br>
`<имя токена, значение атрибута>` <br>
Этот токен передаётся следующей фазе, синтаксическому анализу. Имя токена — абстрактный символ, использующийся во время синтаксического анализа, а опциональное значение атрибута содержит дополнительную информацию, связанную с токеном.<br>

### Синтаксический анализ
Вторая фаза называется синтаксический анализ или разбор, а по-английски parsing. Анализатор — его ещё называют парсер — использует токены, полученные при лексическом анализе для создания промежуточного представления. Оно описывает грамматическую структуру потока токенов. Обычно такое представление — это абстрактное синтаксическое дерево, древовидная структура данных, в которой каждый внутренний узел задаёт операцию, а дочерние узлы — аргументы этой операции.<br>
### Семантический анализ
Семантический анализатор выполняет интерпретацию программы. Он последовательно обходит синтаксическое дерево, выполняя связанные с узлами дерева действия, и обновляет **таблицу символов**.<br>

# Примеры
### 1. Примеры строк в Mython:
```
"hello"
'world'
'long string with a double quote " inside'
"another long string with a single quote ' inside"
"string with a double quote \" inside"
'string with a single quote \' inside'
'', "" — пустые строки.
```

### 2. Примеры коментариев в Mython:
```
# это комментарий
x = 5 #это тоже комментарий
# в следующей строке # - обычный символ
hashtag = "#природа" 
 ```
 
### 3. Примеры идентификаторов в Mython:
```
 Примеры правильных идентификаторов: x, _42, do_something, int2str. Примеры неправильных идентификаторов:
	4four — начинается с цифры;
	one;two — содержит символ, который не относится к цифрам, буквам или знакам подчёркивания.
```

### 4. Пример класса «Прямоугольник»:
```
class Rect:
  def __init__(w, h):
    self.w = w
    self.h = h

  def area():
    return self.w * self.h   
```

### 5. Пример динамической типизации:
```
x = 4        # переменная x связывается с целочисленным значением 4
# следующей командой переменная x связывается со значением 'hello'
x = 'hello'
y = True
x = y 
```

### 6. Пример операции сложения объектов классов со специальным методом **__add__**:
```
   class Fire:
  def __init__(obj):
    self.obj = obj

  def __str__():
    return "Burnt " + str(self.obj)

class Tree:
  def __str__():
    return "tree"

class Matches: # Спички
  # операция сложения спичек с другими объектами превращает их в огонь
  def __add__(smth):
    return Fire(smth)

result = Matches() + Tree()
print result             # Выведет Burnt tree
print Matches() + result # Выведет Burnt Burnt tree
```

### 7. Пример применения операции сравнения к объектам классов:   
```
class Person:
  def __init__(name, age):
    self.name = name
    self.age = age
  def __eq__(rhs):
    return self.name == rhs.name and self.age == rhs.age
  def __lt__(rhs):
    if self.name < rhs.name:
        return True
    return self.name == rhs.name and self.age < rhs.age

print Person("Ivan", 10) <= Person("Sergey", 10) # True
print Person("Ivan", 10) <= Person("Sergey", 9)  # False
```

### 8. Пример класса с методом __str__:
```
class Rect(Shape):
  def __init__(w, h):
    self.w = w
    self.h = h

  def __str__():
    return "Rect(" + str(self.w) + 'x' + str(self.h) + ')' 
```
Выражение str(Rect(3, 4)) вернёт строку Rect(3x4).<br>

### 9. Пример использования условного оператора:
Синтаксис:<br>

```
if <условие>:
  <действие 1>
  <действие 2>
  ...
  <действие N>
else:
  <действие 1>
  <действие 2>
  ...
  <действие M> 
```

**<условие>** — это произвольное выражение, за которым следует двоеточие. Если условие истинно, выполняются действия под веткой **if**, если ложно — действия под веткой **else**. Наличие ветки **else** необязательно.<br>
**<условие>** может содержать сравнения, а также логические операции **and**, **or** и **not**. Условие будет истинным или ложным в зависимости от того, какой тип имеет вычисленное выражение.
Если результат вычисления условия — значение логического типа, для проверки истинности условия используется именно оно. Примеры:<br>
 - `if x > 0:`<br>
 - `if s != 'Jack' and s != 'Ann':`<br>
Если результат вычисления условия — число, условие истинно тогда и только тогда, когда это число не равно нулю, как в C/C++, например, `if x + y:`.<br>
Если результат вычисления условия — строка, условие истинно тогда и только тогда, когда эта строка имеет ненулевую длину.<br>
Если результат вычисления условия — объект класса, условие истинно.<br>
Если результат вычисления условия — None, условие ложно.<br>
Действия в ветках **if** и **else** набраны с отступом в два пробела. В отличие от C++, в котором блоки кода обрамляются фигурными скобками, в языке Mython команды объединяются в блоки отступами. Один отступ равен двум пробелам. Отступ в нечётное количество пробелов считается некорректным.<br> Сравните:

```
if x > 0:
  x = x + 1
print x

if x > 0:
  x = x + 1
  print x 
```
Первая команда `print x` будет выполняться всегда, вторая — только если x больше 0. Вложенность условий может быть произвольной:<br>

```
if x > 0:
  if y > 0:
    print "Эта строка выведется, если x и y положительные"
else:
  print "Эта строка выведется, если x <= 0" 
```

### 10. В примере ниже класс Rect наследуется от класса Shape:
```
class Shape:
  def __str__():
    return "Shape"

  def area():
    return 'Not implemented'

class Rect(Shape):
  def __init__(w, h):
    self.w = w
    self.h = h

  def __str__():
    return "Rect(" + str(self.w) + 'x' + str(self.h) + ')'

  def area():
    return self.w * self.h 
```

Все методы публичные и виртуальные. Например, код ниже выведет Hello, John:<br>

```
class Greeting:
  def greet():
    return "Hello, " + self.name()

  def name():
    return 'Noname'

class HelloJohn(Greeting):
  def name():
    return 'John'

greet_john = HelloJohn()
print greet_john.greet()
```

### 11. Пример семантики присваивания:
Код ниже выведет 2, так как переменные x и y ссылаются на один и тот же объект:

```
class Counter:
  def __init__():
    self.value = 0

  def add():
    self.value = self.value + 1

x = Counter()
y = x
x.add()
y.add()
print x.value 
```
